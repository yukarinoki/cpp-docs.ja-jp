---
title: Visual C++ の ARM への移行に関する一般的な問題
ms.date: 05/06/2019
ms.assetid: 0f4c434e-0679-4331-ba0a-cc15dd435a46
ms.openlocfilehash: 78d87000240acd394edf823a778ae29060c6d09c
ms.sourcegitcommit: da32511dd5baebe27451c0458a95f345144bd439
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 05/07/2019
ms.locfileid: "65220885"
---
# <a name="common-visual-c-arm-migration-issues"></a>Visual C++ の ARM への移行に関する一般的な問題

Microsoft を使用する場合C++コンパイラ (MSVC) 同じC++x86 または x64 のアーキテクチャではよりも、ソース コードは、ARM アーキテクチャに異なる結果を生成可能性があります。

## <a name="sources-of-migration-issues"></a>移行に関する問題のソース

X86 または x64 のアーキテクチャからコードを ARM アーキテクチャに移行するときに発生する多くの問題に関連するソース コードの構造を未定義または指定されていない、実装定義の動作を呼び出すことがあります。

*未定義の動作が*は C++ 標準で定義しない動作であり、妥当な結果がない操作によって発生したたとえば、浮動小数点値を符号なし整数に変換または位置の数によって、値をシフト。負の値またはその型の昇格されたビット数を超えています。

*実装で定義された動作*は C++ 標準では、コンパイラの販売元を定義し、文書化の動作です。 動作の実装定義にそのようにできない場合があります移植可能な場合でも、プログラムが利用しても安全です。 実装定義の動作の例には、組み込みのデータ型とのアラインメント要件のサイズが含まれます。 実装定義の動作の影響を受ける操作の例は、可変個の引数リストにアクセスします。

*動作が指定されていない*は C++ の標準が意図的に非確定的な動作です。 動作は、非決定論的と見なされます、未定義の動作の特定の呼び出しはコンパイラ実装によって決まります。 ただし、結果を事前に定義または同等の呼び出しの間で一貫した動作を保証するためにコンパイラ ベンダー要件はありません、ドキュメントの要件はありません。 未定義の動作の例は、関数呼び出しに対する引数を含めるには、サブ式が評価される順序です。

その他の移行に関する問題は、ARM と C++ の標準と異なる方法で対話する x86 または x64 のアーキテクチャのハードウェアの違いに起因ことができます。 たとえば、x86 および x64 アーキテクチャの強力なメモリ モデルは`volatile`-変数に特定の種類の過去のスレッド間通信を容易にするために使用されているいくつか追加のプロパティを修飾します。 この使用をサポートしていない、ARM アーキテクチャの弱いメモリ モデルもは C++ の標準が必要です。

> [!IMPORTANT]
>  `volatile`向上 x86 および x64、これらの追加プロパティで、スレッド間通信の制限付きのフォームを実装するために使用できる一部のプロパティが実装するための十分なスレッド間の通信で一般的です。 C++ 標準では、代わりに、適切な同期プリミティブを使用して、このような通信を実装することをお勧めします。

困難で、バグが発生しやすい、特定のプラットフォームの動作に依存している場合は、さまざまなプラットフォームでは、異なる方法で動作のような種類を表す場合があります、ために指定プラットフォーム間でのソフトウェアを移植できます。 これらの種類の動作の多くは監視され、安定性が表示される、それらの証明書利用者が少なくともポータブルでない、ありの動作が未定義または未指定の場合、エラー。 このドキュメントに示されている場合は、動作も、依存する必要があり、コンパイラや CPU の実装を後で変更します。

## <a name="example-migration-issues"></a>移行に関する問題の例

このドキュメントの残りの部分では、これらの C++ 言語要素の動作の違いがさまざまなプラットフォームで異なる結果を生成する方法について説明します。

### <a name="conversion-of-floating-point-to-unsigned-integer"></a>符号なし整数の浮動小数点の変換

ARM アーキテクチャに浮動小数点値の 32 ビット整数への変換は飽和を最も近い値を浮動小数点の値は範囲の整数を表すことができる場合、整数を表すことができます。 変換は、x86 および x64 のアーキテクチャで、整数が、署名されていないか、整数が署名されている場合は、-2147483648 に設定されている場合にラップします。 浮動小数点値の小さい整数型への変換を直接サポートなしのこれらのアーキテクチャ代わりに、32 ビットに変換され、結果は小さいサイズに切り捨てられます。

ARM アーキテクチャでは、彩度と切り捨ての組み合わせは、符号なしの型への変換は、小さい符号なし型飽和正しくを行うよりも大きい値の切り捨てられた結果が生成されますが、32 ビット整数を飽和ときに、小さい型は、完全な 32 ビット整数が飽和状態が小さすぎて表現できます。 32 ビットの符号付き整数を変換を正しくも飽和が飽和状態の符号付き整数の切り捨てにより、確実に飽和状態の値の場合は-1 と悪影響飽和状態の値の場合は 0。 小さい符号付き整数に変換するには、予測可能でない切り捨てられた結果が生成されます。

、X86 および x64 のアーキテクチャのラップアラウンド動作の符号なし整数の変換と切り捨て、と共に、オーバーフローの符号付き整数の変換の明示的な評価を組み合わせた結果ようにシフトするほとんどしている場合に予期しません。大きすぎます。

これらのプラットフォームは、NaN (Not a Number) の整数型への変換の処理方法も異なります。 ARM、NaN は 0x00000000; に変換します。x86 と x64 の場合は、0x80000000 に変換します。

浮動小数点の変換は値が変換される整数型の範囲内にいることがわかっている場合に依存のみです。

### <a name="shift-operator---behavior"></a>シフト演算子 (\< \< >>) の動作

ARM アーキテクチャには値を左または右最大 255 ビット パターンの繰り返しが開始される前にシフトするときことができます。 X86 および x64 のアーキテクチャのパターンが 32 のすべての倍数で繰り返しパターンのソースが 64 ビット変数; しない限り、その場合は、x64、x86、ソフトウェアの実装が使用されている 256 の倍数ですべての 64 の倍数ですべてのパターンが繰り返されます。 たとえば、32 ビット変数に 32 の位置を左にシフト 1 の値を持つ、ARM では、結果は 0、x86 上で、結果は 1 で x64 で結果も 1。 ただし、値のソースが 64 ビット変数である場合は、次の 3 つすべてのプラットフォームで、結果は、4294967296、値は「折り返し」256 か所で ARM および x86、x64、または 64 の位置がシフトされた、まで。

ソースの種類のビット数を超える、シフト演算の結果は定義されないために、コンパイラでは、すべての状況で一貫性のある動作を必要はありません。 たとえば、シフトの両方のオペランドはコンパイル時に既知の場合、コンパイラ可能性があります、プログラム、シフトの結果を事前計算を内部のルーチンを使用して、シフト演算の代わりに、結果を置換し、最適化します。 シフト数が多すぎる、または負の値の場合は、内部のルーチンの結果では、CPU によって実行される同じシフトの式の結果よりも異なる可能性があります。

### <a name="variable-arguments-varargs-behavior"></a>可変個の引数 (vararg) の動作

ARM アーキテクチャに可変個の引数リストから、スタックに渡されるパラメーターの配置を受けます。 たとえば、64 ビットのパラメーターは、64 ビットの境界に揃えられます。 X86 と x64 の場合は、スタックに渡される引数が適用されないアラインメントとパック密接にします。 この違いのような可変個引数関数が発生することができます`printf`を目的としていた ARM 上余白として可変個の引数リストの予期されるレイアウトが正確に一致しない場合も、x86 上でいくつかの値のサブセットの動作がありますが、メモリ アドレスを読み取るまたは x64 のアーキテクチャ。 次の例について考えます。

```C
// notice that a 64-bit integer is passed to the function, but '%d' is used to read it.
// on x86 and x64 this may work for small values because %d will “parse” the low-32 bits of the argument.
// on ARM the calling convention will align the 64-bit value and the code will print a random value
printf("%d\n", 1LL);
```

この場合、引数の配置と見なされるように、正しい形式の仕様が使用されることを確認することにより、バグを修正することができます。 このコードが正しいです。

```C
// CORRECT: use %I64d for 64-bit integers
printf("%I64d\n", 1LL);
```

### <a name="argument-evaluation-order"></a>引数の評価順序

X86 および x64、ARM プロセッサが異なるため、コンパイラの実装と最適化の別の機会に異なる要件に提供できます。 呼び出し規約と最適化の設定などの他の要因と共にはこのため、コンパイラがさまざまなアーキテクチャ、またはその他の要因が変更されたときに別の順序で関数の引数を評価する可能性があります。 予期せず変更の特定の評価順序に依存しているアプリの動作がある可能性があります。

この種のエラーは、関数の引数が、同じ呼び出しで関数の他の引数に影響を与える副作用がある場合に発生します。 この種の依存関係が簡単に避けるには、通常がそのことがありますに隠されること、識別が困難な依存関係または演算子のオーバー ロードします。 このコード例を検討してください。

```cpp
handle memory_handle;

memory_handle->acquire(*p);
```

明確に定義されたが、これが表示されますが、場合`->`と`*`がオーバー ロードされた演算子は、このコードは次のように何かに変換されます。

```cpp
Handle::acquire(operator->(memory_handle), operator*(p));
```

間の依存関係がある場合と`operator->(memory_handle)`と`operator*(p)`可能な依存関係がない場合でも、元のコードでは、次のように、コードが一定の評価順序に依存します。

### <a name="volatile-keyword-default-behavior"></a>volatile キーワードの既定の動作

MSVC コンパイラ サポートの 2 つの異なる解釈、`volatile`記憶域の修飾子をコンパイラ スイッチを使用して指定することができます。 [/Volatile:ms](reference/volatile-volatile-keyword-interpretation.md)スイッチは、それらのアーキテクチャの強力なメモリ モデルであるため、x86 と x64 用の従来のケースが済みとしての厳密な順序は保証揮発性のセマンティクスを拡張する Microsoft を選択します。 [/Volatile:iso](reference/volatile-volatile-keyword-interpretation.md)スイッチは、厳密な C++ 標準揮発性のセマンティクスを厳密な順序は保証されないを選択します。

既定値は、ARM アーキテクチャに **/volatile:iso** ARM プロセッサがあるメモリ モデルでは、順序付けられた十分ではないため、および ARM のソフトウェアは、従来の拡張のセマンティクスに頼る必要があるないため **/volatile:ms**がない、通常とはソフトウェアとのインターフェイス。 ただし、場合によって不便または拡張のセマンティクスを使用して、ARM プログラムをコンパイルする必須です。 たとえば、ISO C のセマンティクスを使用するプログラムを移植するコストがかかりすぎる可能性があるまたはドライバー ソフトウェアが正常に機能する従来のセマンティクスに準拠する必要があります。 このような場合は、使用することができます、 **/volatile:ms**スイッチただし、ARM のターゲットに従来の揮発性のセマンティクスを再作成するコンパイラする必要がありますメモリ バリアを挿入ごとの読み取りまたは書き込みの周りを`volatile`変数が強制するには。厳密な順序では、パフォーマンスに悪影響を及ぼすことができます。

既定では、x86 および x64 アーキテクチャで **/volatile:ms** MSVC を使用してこれらのアーキテクチャを既に作成されているソフトウェアの多くに依存しているためです。 X86 および x64 のプログラムをコンパイルするときに指定できます、 **/volatile:iso**スイッチの従来の揮発性のセマンティクスに不要な依存を回避して、移植性を促進します。

## <a name="see-also"></a>関連項目

[ARM プロセッサ用の Visual C ++ の構成する](configuring-programs-for-arm-processors-visual-cpp.md)
