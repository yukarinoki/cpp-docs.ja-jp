---
title: x64 プロローグとエピローグ
ms.date: 12/17/2018
ms.assetid: 0453ed1a-3ff1-4bee-9cc2-d6d3d6384984
ms.openlocfilehash: a225786853fcc2eb7b6a21de29f1ccf4901e4377
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "62295242"
---
# <a name="x64-prolog-and-epilog"></a>x64 プロローグとエピローグ

スタック領域の割り当てをすべての関数呼び出し他の関数、不揮発性レジスタの保存または例外処理を使用では、プロローグ アンワインド データが各関数のテーブル エントリに関連付けられているアドレスの制限が説明されている必要があります。 詳細については、次を参照してください。 [x64 例外処理](../build/exception-handling-x64.md)します。 プロローグでは、引数のレジスタ、自宅の住所で必要に応じて、不揮発性レジスタ、スタックにプッシュ、ローカル、一時要素は、スタックの固定部分を割り当てるし、フレーム ポインターを必要に応じて確立を保存します。 関連付けられているデータのアンワインド、プロローグのアクションを記述する必要があり、プロローグ コードの効果を元に戻すために必要な情報を提供する必要があります。

スタック内の固定割り当てが 1 つ以上のページ (つまり、4096 バイトより大きい)、スタック割り当てが 1 つ以上の仮想メモリ ページにわたることがあり、そのため、割り当てられる前に、割り当てをチェックする必要がある可能性があります。 特殊なルーチンは、プロローグから呼び出すことと、引数のレジスタが破棄されませんが、この目的に提供されます。

不揮発性レジスタを保存するための推奨される方法では、固定のスタック割り当てする前にスタックに移動します。 固定のスタック割り当てが実行されるは、不揮発性レジスタを保存する前に場合、可能性が最も高い 32 ビットの変位必要は保存されたレジスタの領域に対処します。 (報告されているレジスタのプッシュは高速に移動し、プッシュの間の暗黙的な依存関係のあるにもかかわらず、近い将来のためを維持する必要があります)。任意の順序では、不揮発性レジスタを保存できます。 ただし、不揮発性レジスタ プロローグ内の最初の使用は、保存する必要があります。

## <a name="prolog-code"></a>プロローグ コード

典型的なプロローグ コードは次のようになります。

```MASM
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    sub    RSP, fixed-allocation-size
    lea    R13, 128[RSP]
    ...
```

このプロローグのホーム場所引数 RCX レジスタに格納、保存の不揮発性 R13 R15 を登録、スタック フレームの固定部分を割り当てます 128 バイトを指すの固定割り当て領域にフレーム ポインターを確立します。 オフセットを使用すると、複数の固定割り当て領域の 1 バイトのオフセットで対処できます。

固定の割り当てのサイズがメモリのページを 1 つ以上の場合は、RSP を変更する前に、ヘルパー関数を呼び出す必要があります。 このヘルパーでは、`__chkstk`スタックが適切に拡張することを確認するスタックの割り当てされる範囲をプローブします。 その場合は、プロローグの前の例はようになります。

```MASM
    mov    [RSP + 8], RCX
    push   R15
    push   R14
    push   R13
    mov    RAX,  fixed-allocation-size
    call   __chkstk
    sub    RSP, RAX
    lea    R13, 128[RSP]
    ...
```

`__chkstk`ヘルパーでは、任意のレジスタ R10、R11、および条件コード以外は変更されません。 具体的には、そのまま RAX を返すされすべての不揮発性レジスタと引数を渡すレジスタが未変更の状態のままにします。

## <a name="epilog-code"></a>エピローグ コード

エピローグ コードは、各終了関数に存在します。 一方、通常 1 つだけプロローグは、多くのエピローグがあります。 エピローグ コードは、(必要な) 場合、スタックの固定割り当てのサイズをトリム、固定のスタック割り当ての割り当てを解除して、保存されている値をスタックからポップすることで不揮発性レジスタを復元したうえを返します。

エピローグ コードは、例外および割り込みが確実にアンワインドする厳密な一連のアンワインド コードの規則に従う必要があります。 これらの規則の量を減らす各エピローグを記述する追加のデータは必要ありませんので、必要なデータをアンワインドします。 代わりに、アンワインド コードは、エピローグを識別するコード ストリームを前方向にスキャンして、エピローグが実行されていることを確認できます。

関数エピローグする必要があります最初の割り当てを解除、スタックの固定部分でフレーム ポインターを使用しない場合、不揮発性レジスタをポップ、および呼び出し元の関数に制御が返されます。 例えば以下のようにします。

```MASM
    add      RSP, fixed-allocation-size
    pop      R13
    pop      R14
    pop      R15
    ret
```

フレーム ポインターを関数で使用する場合は、エピローグの実行前に、固定の割り当てにスタックをトリムする必要があります。 この操作には、技術的には含まれていない、エピローグです。 たとえば、次のエピローグを使用して、以前使用したプロローグを取り消します。

```MASM
    lea      RSP, -128[R13]
    ; epilogue proper starts here
    add      RSP, fixed-allocation-size
    pop      R13
    pop      R14
    pop      R15
    ret
```

実際には、フレーム ポインターを使用する場合は次のエピローグが代わりに使用されるため、2 つの手順で RSP を調整する理由。

```MASM
    lea      RSP, fixed-allocation-size - 128[R13]
    pop      R13
    pop      R14
    pop      R15
    ret
```

これらの形式は、エピローグの法的なだけのものです。 いずれかで構成されている必要があります、`add RSP,constant`または`lea RSP,constant[FPReg]`一連の 0 個以上の 8 バイト レジスタ pop と、その後、`return`または`jmp`します。 (のサブセットのみ`jmp`ステートメントでは、エピローグで許容されます。 サブセットの専用のクラスは、 `jmp` ModRM mod フィールド値が 00 は ModRM メモリ参照を含むステートメント。 使用`jmp`01 または 10 mod フィールドの値が禁止されている ModRM エピローグ内のステートメント。 AMD の x86 64 アーキテクチャ プログラマの手動の第 3 のテーブル A-15 を参照してください。General Purpose と許容 ModRM 参照の詳細については、システムの手順です。)その他のコードを表示できません。 具体的には、戻り値の読み込みを含め、エピローグ内で何もスケジュールできます。

フレーム ポインターを使用しない場合、エピローグを使用する必要があります`add RSP,constant`スタックの固定部分の割り当てを解除します。 使用されて`lea RSP,constant[RSP]`代わりにします。 この制限には、アンワインド コードはエピローグを検索するときに認識されるパターンが存在します。

これらの規則では、エピローグが現在実行されていることを確認して、呼び出し元関数のコンテキストを再作成を許可するエピローグの残りの部分の実行をシミュレートするためにアンワインド コード。

## <a name="see-also"></a>関連項目

[x64 ソフトウェア規約](x64-software-conventions.md)
