---
title: x64 での呼び出し規則
description: 既定の x64 ABI の呼び出し規約の詳細です。
ms.date: 12/17/2018
ms.assetid: 41ca3554-b2e3-4868-9a84-f1b46e6e21d9
ms.openlocfilehash: 2cad00ac7f2cb5fe086fa262a0f512330997391f
ms.sourcegitcommit: 0e3da5cea44437c132b5c2ea522bd229ea000a10
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 07/12/2019
ms.locfileid: "67861159"
---
# <a name="x64-calling-convention"></a>x64 での呼び出し規則

このセクションでは、標準のプロセスと x64 の別の関数 (呼び出し先) に呼び出しを実行する 1 つの関数 (呼び出し元) を使用する規則について説明します。 コード。

## <a name="calling-convention-defaults"></a>呼び出し規則の既定値

既定のアプリケーション バイナリ インターフェイス (ABI) によって、4 つの登録を高速呼び出しの呼び出し規約を使用して x64 です。 これらのレジスタを保存する呼び出し先のシャドウ ストアとしてコール スタックに領域が割り当てられます。 関数呼び出しに引数とそれらの引数に使用されるレジスタの間は、厳密な一対一で対応します。 8 バイトに収まらないか、1、2、4、または 8 バイトは、引数は、参照渡しする必要があります。 1 つの引数は、複数のレジスタを分散ことはありません。 X87 stack の登録は、使用されていないと、呼び出し先で使用することが考慮する必要が揮発性関数呼び出しで。 すべての浮動小数点操作が完了したら個の XMM レジスタを 16 を使用します。 整数の引数が RCX、RDX、R8、および R9 レジスタに渡されます。 浮動小数点引数は XMM0L、XMM1L、XMM2L、および XMM3L で渡されます。 16 バイトの引数は、参照によって渡されます。 パラメーターの引き渡しがで詳しく説明されている[パラメーターの引き渡し](#parameter-passing)します。 これらのレジスタだけでなく RAX、R10、R11、XMM4、および XMM5 と見なされます揮発性。 その他のすべてのレジスタは、非揮発性です。 レジスタの使用量の詳細に記載されている[Usage の登録](../build/x64-software-conventions.md#register-usage)と[呼び出し元/呼び出し先保存登録](#callercallee-saved-registers)します。

プロトタイプ宣言された関数の場合は、すべての引数が渡される前に予期される呼び出し先の型に変換されます。 呼び出し元は、呼び出し先へのパラメーター領域を割り当てる必要があり、呼び出し先はそれほど多くのパラメーターを受け取るしない場合でも常に、4 つの登録パラメーターを格納するための十分な領域を割り当てる必要があります。 この規則は、C 言語の関数のプロトタイプ宣言されていないと vararg C と C++ の関数のサポートを簡略化します。 Vararg またはプロトタイプ宣言されていない関数では、任意の浮動小数点値をする必要があります、対応する汎用レジスタ内で重複します。 呼び出しの前に影を格納後、最初の 4 つを超えるすべてのパラメーターをスタックに格納する必要があります。 Vararg 関数の詳細が記載されて[Varargs](#varargs)します。 プロトタイプ宣言されていない関数についての詳細については[プロトタイプ宣言されていない関数](#unprototyped-functions)します。

## <a name="alignment"></a>アラインメント

ほとんどの構造体は、自然なアラインメントに揃えて配置されます。 プライマリの例外は、スタック ポインターと`malloc`または`alloca`メモリで、パフォーマンスを支援するために、16 バイトに揃えられます。 16 バイトを超える配置を手動で行う必要がありますが、XMM 操作の一般的な配置のサイズを 16 バイトには、この値がほとんどのコードの作業する必要があります。 構造体レイアウトやアラインメントの詳細については、次を参照してください。[型とストレージ](../build/x64-software-conventions.md#types-and-storage)します。 スタックのレイアウトについては、次を参照してください。 [x64 スタックの使用状況](../build/stack-usage.md)します。

## <a name="unwindability"></a>Unwindability

リーフ関数は、任意の非 volatile レジスタが変更されない関数です。 非リーフ関数は、関数を呼び出すか、ローカル変数の追加のスタック領域の割り当てによって、非揮発性 RSP をたとえば、変更できます。 例外を処理するときに非 volatile レジスタを回復するには、非リーフ関数を正しく任意命令に関数をアンワインドする方法を説明する静的データで注釈する必要があります。 このデータとして格納されます*pdata*、またはプロシージャのデータは、順番を指す*xdata*、例外データを処理します。 Xdata アンワインドの情報を格納し、追加 pdata または例外のハンドラー関数を指すことができます。 プロローグとエピローグは、正しく xdata で説明されている可能性があるように高度に制限されます。 スタック ポインターは、16 バイトのプロローグまたはエピローグの一部を除くリーフ関数の中でないコードを任意のリージョン内に配置する必要があります。 リーフ関数は、pdata および xdata は必要ありませんので、戻り値をシミュレートするだけでさかのぼることができます。 詳細については、関数プロローグとエピローグの適切な構造は、次を参照してください。 [x64 プロローグとエピローグ](../build/prolog-and-epilog.md)します。 例外処理、および例外処理アンワインディング pdata と xdata の詳細については、次を参照してください。 [x64 例外処理](../build/exception-handling-x64.md)します。

## <a name="parameter-passing"></a>パラメーター渡し

最初の 4 つの整数引数はレジスタで渡されます。 整数値は、それぞれで RCX、RDX、R8、および R9、左から右の順序で渡されます。 5 つの引数以上スタックに渡されるとします。 すべての引数がレジスタに右揃え、呼び出し先がレジスタの上位ビットを無視し、必要なレジスタの部分にのみアクセスできるようにします。

最初の 4 つのパラメーターと倍精度の浮動小数点引数は、位置に応じて XMM0 - XMM3 で渡されます。 RCX、RDX、R8、および R9 これらの位置に通常使用される整数レジスタは無視されます、varargs 引数は除きます。 詳細については、次を参照してください。 [Varargs](#varargs)します。 同様に、XMM0 - XMM3 レジスタは、対応する引数が整数またはポインター型で無視されます。

[_ _m128](../cpp/m128.md)型、配列、および文字列がイミディ エイト値によって渡されることはありません。 代わりに、呼び出し元が割り当てたメモリへのポインターが渡されます。 場合、同じサイズの整数と同様の構造体と共用体のサイズが 8、16、32、または 64 ビット、および、_ _m64 型が渡されます。 構造体または共用体の他のサイズは、呼び出し元が割り当てたメモリへのポインターとして渡されます。 このような集計の種類のポインターとしてやり取りされるなど\__m128、呼び出し元が割り当てたの一時的なメモリは 16 バイトでアラインする必要があります。

場合によって、スタックの領域の割り当てをしないし、他の関数を呼び出さないでください組み込み関数は、追加のレジスタ引数を渡す他 volatile レジスタを使用します。 この最適化は、コンパイラと組み込み関数の実装間の緊密なバインドによって実現されます。

呼び出し先は、登録パラメーターを必要な場合は、そのシャドウ領域にダンプします。

次の表では、パラメーターが渡される方法を示します。

|パラメーターの型|渡された方法|
|--------------------|----------------|
|浮動小数点数|最初に 4 つのパラメーター - XMM3 を通じて XMM0 します。 他のユーザーは、スタックで渡されます。|
|整数型|最初に 4 つのパラメーター - RCX、RDX、R8、R9。 他のユーザーは、スタックで渡されます。|
|集計 (8、16、32、または 64 ビット) と _ _m64|最初に 4 つのパラメーター - RCX、RDX、R8、R9。 他のユーザーは、スタックで渡されます。|
|集計 (その他)|ポインター。 まず、4 つのパラメーターが RCX、RDX、R8、および R9 のポインターとして渡されます|
|__m128|ポインター。 まず、4 つのパラメーターが RCX、RDX、R8、および R9 のポインターとして渡されます|

### <a name="example-of-argument-passing-1---all-integers"></a>1 - すべての整数を渡す引数の例

```cpp
func1(int a, int b, int c, int d, int e);
// a in RCX, b in RDX, c in R8, d in R9, e pushed on stack
```

### <a name="example-of-argument-passing-2---all-floats"></a>2 - すべての浮動小数点値を渡す引数の例

```cpp
func2(float a, double b, float c, double d, float e);
// a in XMM0, b in XMM1, c in XMM2, d in XMM3, e pushed on stack
```

### <a name="example-of-argument-passing-3---mixed-ints-and-floats"></a>3 - 混合整数と浮動小数点数を渡す引数の例

```cpp
func3(int a, double b, int c, float d);
// a in RCX, b in XMM1, c in R8, d in XMM3
```

### <a name="example-of-argument-passing-4--m64-m128-and-aggregates"></a>引数渡し 4 の例-、_ _m64 \__m128 と集計

```cpp
func4(__m64 a, _m128 b, struct c, float d);
// a in RCX, ptr to b in RDX, ptr to c in R8, d in XMM3
```

## <a name="varargs"></a>vararg

Varargs (たとえば、省略記号引数) を使用してパラメーターが渡されると場合、通常登録パラメーター規則を渡すことは適用されます、によってが書き込まれる 5 番目と後続の引数は、スタックを含むです。 アドレスを取得する引数をダンプする、呼び出し先の責任です。 浮動小数点値の場合にのみ、整数レジスタと浮動小数点レジスタの両方含める必要があります、値場合は、呼び出し先は、整数レジスタに値が必要です。

## <a name="unprototyped-functions"></a>プロトタイプ宣言されていない関数

関数の完全なプロトタイプではない場合は、呼び出し元は、整数と浮動小数点値として整数値を倍精度として渡します。 浮動小数点値の場合にのみ、整数レジスタと浮動小数点レジスタの両方が含まれている浮動小数点値場合は、呼び出し先は、整数レジスタに値が必要です。

```cpp
func1();
func2() {   // RCX = 2, RDX = XMM1 = 1.0, and R8 = 7
   func1(2, 1.0, 7);
}
```

## <a name="return-values"></a>戻り値

RAX; から 64 ビットに収まるスカラー戻り値が返されますこれには、_ _m64 型が含まれます。 Float、double 型、およびなどのベクター型を含む非スカラー型型[_ _m128](../cpp/m128.md)、 [_ _m128i](../cpp/m128i.md)、 [_ _m128d](../cpp/m128d.md) XMM0 で返されます。 RAX や XMM0 で返される値の未使用ビットの状態は未定義です。

ユーザー定義型は、グローバル関数や静的メンバー関数からの値で返すことができます。 値によって RAX にユーザー定義型を返すには、1、2、4、8、16、32、または 64 ビットの長さが必要です。 必要ないユーザー定義のコンス トラクター、デストラクター、またはコピー代入演算子。プライベートまたはプロテクトの非静的データ メンバーはありません。参照型の非静的データ メンバーはありません。基底クラスを持たない。仮想関数はありません。これらの要件も満たさないデータ メンバーがありません。 (これは、実質的には C++03 POD 型の定義です。 使用は推奨されませんので、標準の c++ 11 で変更が定義され、`std::is_pod`このテストします)。それ以外の場合は、呼び出し元が、メモリを割り当て、最初の引数として戻り値のポインターを渡す必要があります。 後続する引数は、引数 1 つ分だけ右にシフトされます。 RAX 内の呼び出し先は同じポインターを返す必要があります。

以下の例は、宣言を指定して関数に対してパラメーターと戻り値を渡す方法を示しています。

### <a name="example-of-return-value-1---64-bit-result"></a>戻り値 1 - 64 ビットの結果の例

```Output
__int64 func1(int a, float b, int c, int d, int e);
// Caller passes a in RCX, b in XMM1, c in R8, d in R9, e pushed on stack,
// callee returns __int64 result in RAX.
```

### <a name="example-of-return-value-2---128-bit-result"></a>2 - 128 ビットの結果の戻り値の例

```Output
__m128 func2(float a, double b, int c, __m64 d);
// Caller passes a in XMM0, b in XMM1, c in R8, d in R9,
// callee returns __m128 result in XMM0.
```

### <a name="example-of-return-value-3---user-type-result-by-pointer"></a>3 - ポインターによるユーザー型の結果の戻り値の例

```Output
struct Struct1 {
   int j, k, l;    // Struct1 exceeds 64 bits.
};
Struct1 func3(int a, double b, int c, float d);
// Caller allocates memory for Struct1 returned and passes pointer in RCX,
// a in RDX, b in XMM2, c in R9, d pushed on the stack;
// callee returns pointer to Struct1 result in RAX.
```

### <a name="example-of-return-value-4---user-type-result-by-value"></a>4 - 値によるユーザー型の結果の戻り値の例

```Output
struct Struct2 {
   int j, k;    // Struct2 fits in 64 bits, and meets requirements for return by value.
};
Struct2 func4(int a, double b, int c, float d);
// Caller passes a in RCX, b in XMM1, c in R8, and d in XMM3;
// callee returns Struct2 result by value in RAX.
```

## <a name="callercallee-saved-registers"></a>呼び出し元/呼び出し先保存済みレジスタ

RAX、RCX、RDX、R8、R9、R10、R11、XMM0 ~ 5、および場合は YMM0 ~ 15 と ZMM0 15 の上の部分は揮発性と見なされます、見なす必要があります、レジスタが関数の呼び出しで破棄 (しない限り、それ以外の場合の安全性が証明可能なプログラム全体の最適化などの分析によって)。 AVX512VL、16 ~ 31 の ZMM、YMM、および XMM レジスタは揮発性です。

RBX、RBP、RDI、RSI、RSP、R12、R13、R14、R15、および XMM6 15 レジスタの不揮発性と見なされます保存する必要がありますや関数によって復元されるそれらを使用します。

## <a name="function-pointers"></a>関数ポインター
 
関数ポインターは、個々 の関数のラベルへのポインターだけです。 関数ポインターの目次 (TOC) の要件の表ではありません。

## <a name="floating-point-support-for-older-code"></a>古いコードの浮動小数点サポート

MMX と浮動小数点スタック レジスタ (MM0-MM7/st0 を割り当てます-ST7) は、コンテキストの切り替えの間で保持されます。 これらのレジスタの明示的な呼び出し規約はありません。 これらのレジスタの使用は、カーネル モード コードで禁じられています。

## <a name="fpcsr"></a>FpCsr

レジスタの状態にも、x87 FPU 制御ワード。 呼び出し規約では、このレジスタを不揮発性によって決まります。

X87 FPU 制御ワードのレジスタの先頭に次の標準的な値に設定されているプログラムの実行。

| 登録\[ビット] | 設定 |
|-|-|
| FPCSR\[0:6] | 例外はすべて 1 の (すべての例外マスク) をマスクします。 |
| FPCSR\[7] | 予約 - 0 |
| FPCSR\[8:9] | 精度の制御 - 10B (有効桁数を 2 倍) |
| FPCSR\[10時 11分] | 丸め制御 - 0 (round を最も近い) |
| FPCSR\[12] | 無限の制御 - 0 (未使用) |

FPCSR 内のフィールドのいずれかを変更する呼び出し先は、呼び出し元に返す前にそれらを復元する必要があります。 さらに、呼び出し元がこれらのフィールドのいずれかが変更する必要がありますの標準値の前に復元アグリーメントによって、呼び出し先が変更後の値を期待しない限り、呼び出し先を呼び出します。

非揮発性に関する規則に制御フラグの 2 つの例外があります。

1. 不揮発性 FpCsr を変更するが、指定された関数のドキュメント化の目的の関数でフラグを設定します。

1. ある場合に、これらの規則の違反が、これらの規則は違反すると、たとえば、プログラム全体の分析によって、プログラムと同様に動作するプログラムで結果を修正します。

## <a name="mxcsr"></a>MxCsr

レジスタの状態には、MxCsr も含まれています。 呼び出し規約は、揮発性の部分と不揮発性の部分にこのレジスタを分割します。 揮発性の部分から成る、MXCSR の 6 つのステータス フラグ\[0:5]、MXCSR レジスタの残りの部分を while\[6時 15分]、不揮発性と見なされます。

不揮発性の部分は、プログラムの実行の開始時に、次の標準的な値に設定されます。

| 登録\[ビット] | 設定 |
|-|-|
| MXCSR\[6] | Denormals 0 - 0 のられます |
| MXCSR\[7時 12分] | 例外はすべて 1 の (すべての例外マスク) をマスクします。 |
| MXCSR\[13時 14分] | 丸め制御 - 0 (round を最も近い) |
| MXCSR\[15] | マスクされたアンダー フロー - 0 (オフ) に 0 へのフラッシュします。 |

MXCSR 内不揮発性のフィールドのいずれかを変更する呼び出し先は、呼び出し元に返す前にそれらを復元する必要があります。 さらに、呼び出し元がこれらのフィールドのいずれかが変更する必要がありますの標準値の前に復元アグリーメントによって、呼び出し先が変更後の値を期待しない限り、呼び出し先を呼び出します。

非揮発性に関する規則に制御フラグの 2 つの例外があります。

- 不揮発性の MxCsr を変更するが、指定された関数のドキュメント化の目的の関数でフラグを設定します。

- ある場合に、これらの規則の違反が、これらの規則は違反すると、たとえば、プログラム全体の分析によって、プログラムと同様に動作するプログラムで結果を修正します。

関数の境界を越えて MXCSR の揮発性の部分の状態に関する仮定は行われません関数のドキュメントで説明されている場合を除き、します。

## <a name="setjmplongjmp"></a>setjmp/longjmp の使用

呼び出す setjmpex.h または setjmp.h を含めると、 [setjmp](../c-runtime-library/reference/setjmp.md)または[longjmp](../c-runtime-library/reference/longjmp.md)を呼び出すデストラクター アンワインドが発生し、`__finally`呼び出し。  一方、x86、含む setjmp.h が結果に`__finally`句とデストラクターを呼び出さない。

呼び出し`setjmp`現在のスタック ポインター、非 volatile レジスタ、および MxCsr レジスタに保持されます。  呼び出す`longjmp`最新に戻り`setjmp`呼び出しサイトとリセット スタック ポインター、非 volatile レジスタ、および MxCsr レジスタ、状態に戻すように、最新では保持されます`setjmp`呼び出します。

## <a name="see-also"></a>関連項目

[x64 ソフトウェア規約](../build/x64-software-conventions.md)
