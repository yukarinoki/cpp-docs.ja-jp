---
title: x64 スタック使用量
ms.date: 12/17/2018
ms.assetid: 383f0072-0438-489f-8829-cca89582408c
ms.openlocfilehash: 902e4304ac124be46c6edf0860118dc522b34890
ms.sourcegitcommit: 0ab61bc3d2b6cfbd52a16c6ab2b97a8ea1864f12
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "62314825"
---
# <a name="x64-stack-usage"></a>x64 スタック使用量

RSP の現在のアドレスを超えるすべてのメモリは揮発性と見なされます。OS、または、デバッガーは、ユーザーのデバッグ セッションでは、または、割り込みハンドラーの中に、このメモリを上書きする可能性があります。 したがって、RSP は常に読み取りまたはスタック フレームに値を書き込みを試行する前に設定する必要があります。

このセクションでは、ローカル変数のスタック領域の割り当てをについて説明しますと、 **alloca**組み込み。

## <a name="stack-allocation"></a>スタック割り当て

関数のプロローグをローカル変数のスタック領域を割り当て、保存済みレジスタ、スタック パラメーター、およびパラメーターを登録します。

パラメーター領域は、スタックの下部に常に、(場合でも`alloca`使用) は常に、リターン アドレスの横にある任意の関数の呼び出し中にいるため、します。 少なくとも 4 つのエントリが含まれていますが、呼び出されるすべての関数が常にすべてのパラメーターを保持するのに十分な領域が必要です。 パラメーター自体がスタックに戻されない場合でも、登録パラメーターの領域が常に割り当てられることに注意してください。呼び出し先のすべてのパラメーター領域が割り当てられていることが保証されます。 自宅の住所がレジスタ引数の必要なは、呼び出された関数が引数リスト (va_list) または個々 の引数のアドレスを取得する必要がある場合に、連続した領域があるため。 この領域には、サンクの実行中に、デバッグ オプションとして、レジスタ引数を保存する便利な場所も用意されています (たとえば、簡単、引数、プロローグ コードでそのホーム アドレスに格納されている場合、デバッグ中に検索する)。 呼び出された関数が 4 未満のパラメーターを持つ場合でも、これら 4 つのスタックの場所は、呼び出された関数では、実質的が所有し、パラメーターのレジスタの値を保存するだけでなく、他の目的で呼び出された関数で使用できます。  したがって、呼び出し元可能性があります情報を保存できませんスタックのこの領域で、関数呼び出しで。

領域が動的に割り当てられている場合 (`alloca`) 関数で、不揮発性レジスタする必要がありますフレーム ポインターとしてを使用、スタックの固定部分のベースをマークとするレジスタを保存し、プロローグで初期化する必要があります。 そのときに注意してください`alloca`が使用すると、同じ呼び出し元から、同じ呼び出し先への呼び出しは、登録パラメーター用の別の自宅の住所を必要があります。

スタックには 16 バイトが維持されます常に (たとえば、リターン アドレスをプッシュした後)、プロローグ内し、で示される場合を除き、[関数型](#function-types)のフレームの関数の特定のクラス。

非リーフの A を関数呼び出しが B. 関数 A のプロローグを関数のスタック レイアウトの例 B が、スタックの一番下に必要なすべてのレジスタとスタック パラメーターの領域を割り当て済みを次に示します。 呼び出しは、リターン アドレスをプッシュし、B のプロローグは、ローカル変数、不揮発性レジスタ、および関数を呼び出すために必要な領域の領域を割り当てます。 B を使用している場合`alloca`、ローカル変数/不揮発性レジスタ保存領域とパラメーターのスタック領域の間に空白を割り当てます。

![AMD 変換例](../build/media/vcamd_conv_ex_5.png "AMD 変換例")

関数 B が別の関数を呼び出すと、リターン アドレスが RCX の自宅の住所のすぐ下にプッシュされます。

## <a name="dynamic-parameter-stack-area-construction"></a>動的なパラメーター スタック領域の構成

フレーム ポインターを使用する場合は、パラメーターのスタック領域を動的に作成するオプションが存在します。 これは現在実行されません、x64 コンパイラ。

## <a name="function-types"></a>関数の型

基本的には、関数の 2 つの種類があります。 スタック フレームを必要とする関数を呼び出す、*関数をフレーム*します。 スタック フレームを必要としない関数を呼び出す、*リーフ関数*します。

フレームの関数は、スタック領域の割り当て、その他の関数を呼び出し、不揮発性レジスタを保存または例外処理を使用する関数です。 関数のテーブルのエントリも必要です。 フレームの関数は、プロローグとエピローグが必要です。 フレームの関数では、スタック領域を動的に割り当てることができます、フレーム ポインターを使用できます。 フレーム関数には、標準的な破棄された時点の呼び出しのすべての機能がいます。

フレームの関数が別の関数を呼び出さないかどうかは、スタックを配置する必要はありません (セクションで参照されている[スタック割り当て](#stack-allocation))。

リーフ関数とは、関数のテーブルのエントリは不要です。 など、任意の関数を呼び出すまたはスタック領域の割り当てできないということを意味 RSP、不揮発性レジスタに加えることはできません。 実行中にスタックの整列されていないままにすることができます。

## <a name="malloc-alignment"></a>malloc アライメント

[malloc](../c-runtime-library/reference/malloc.md)メモリが割り当てられるメモリ量に合わせて基本的なアラインメントとを持つ任意のオブジェクトを格納するは、アラインメントを返すことが保証されます。 A*基本的なアラインメント*小さいアラインメントを指定せずに実装によってサポートされている最大の配置を配置します。 (Visual C++ の基本的なアラインメントは、`double` つまり 8 バイトに対して必要なアラインメントです。 64 ビット プラットフォームを対象としたコードでは 16 バイトです)。たとえば、4 バイト割り当ての場合、4 バイト以下のオブジェクトをサポートする境界上にアラインメントされます。

Visual C の許可を持つ型*拡張アラインメント*とも呼ばれるは*オーバーア ラインされた*型。 たとえば、SSE 型[_ _m128](../cpp/m128.md)と`__m256`を使用して宣言されている型と`__declspec(align( n ))`場所`n`8 より大きい値は、配置を拡張します。 オブジェクトで拡張アラインメントが必要な場合、そのオブジェクトに適した境界上でのメモリのアラインメントは、`malloc` によって保証されません。 オーバーア ラインされている型のメモリを割り当てるには、使用[_aligned_malloc](../c-runtime-library/reference/aligned-malloc.md)および関連する関数。

## <a name="alloca"></a>alloca

[_alloca](../c-runtime-library/reference/alloca.md) 16 バイトに揃えられ、またフレーム ポインターを使用する必要がありますが必要です。

説明したように、後で呼び出された関数のパラメーターの後にスペースを含める必要がありますに割り当てられるスタック[スタック割り当て](#stack-allocation)します。

## <a name="see-also"></a>関連項目

[x64 ソフトウェア規約](../build/x64-software-conventions.md)<br/>
[align](../cpp/align-cpp.md)<br/>
[__declspec](../cpp/declspec.md)
