---
title: イベント (C++/CX)
ms.date: 01/22/2017
ms.assetid: 31c8e08a-00ad-40f9-8f7e-124864aaad58
ms.openlocfilehash: 8e7e8616831e66a7f59ed849fc92ef2553aadb5b
ms.sourcegitcommit: dedd4c3cb28adec3793329018b9163ffddf890a4
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/11/2019
ms.locfileid: "57745084"
---
# <a name="events-ccx"></a>イベント (C++/CX)

(発行、) を Windows ランタイム型を宣言できますイベント、および同じコンポーネント内またはその他のコンポーネントでのクライアント コードと呼ばれるメソッドを関連付けることによってそれらのイベントにサブスクライブできる*イベント ハンドラー*イベントにします。 複数のイベント ハンドラーを単一のイベントに関連付けることもできます。 発行オブジェクトがイベントを発生させた時点で、すべてのイベント ハンドラーが呼び出される結果になります。 この方法で、発行側がイベントを発生させたときに、サブスクライブ側クラスはあらゆる適切なカスタム アクションを実行できます。 各イベントには、そのイベントにサブスクライブしようとするすべてのイベント ハンドラーが所有している必要があるシグネチャを指定するデリゲート型があります。

## <a name="consuming-events-in-windows-components"></a>Windows コンポーネントでのイベントの利用

多くの Windows ランタイム コンポーネントは、イベントを公開します。 たとえば、LightSensor オブジェクトは、センサーが新しい発光値を報告すると ReadingChanged イベントを発生させます。 プログラム内で LightSensor オブジェクトを使用する場合、ReadingChanged イベントが発生したときに呼び出されるメソッドを定義できます。 メソッドは処理でも行うことにしないでください。唯一の要件は、そのシグネチャがデリゲート イベント ハンドラーを作成し、イベントにサブスクライブするを参照してください方法の詳細については、デリゲートのシグネチャに一致する必要があります[デリゲート](../cppcx/delegates-c-cx.md)します。

## <a name="creating-custom-events"></a>カスタム イベントの作成

### <a name="declaration"></a>宣言

ref クラスまたはインターフェイスでイベントを宣言できます。イベントは、public、internal (public/private)、public protected、protected、private protected、または private のアクセシビリティを持つことができます。 イベントを宣言する場合、コンパイラは内部で、add および remove という 2 つのアクセサー メソッドを公開するオブジェクトを作成します。 サブスクライブ側のオブジェクトがイベント ハンドラーを登録した時点で、イベント オブジェクトはそれらのイベント ハンドラーをコレクションに格納します。 イベントが発生すると、イベント オブジェクトはリスト内のすべてのハンドラーを順番に呼び出します。 次の例のような単純なイベントには、暗黙のバッキング ストアと共に暗黙の `add` および `remove` アクセサー メソッドがあります。 また、プロパティにカスタムの `get` アクセサーと `set` アクセサーを指定するのと同じ方法で、独自のアクセサーを指定することもできます。  実装するクラスは、単純なイベントのイベント サブスクライバーの一覧内を手動で循環することはできません。

次の例に、イベントを宣言して発生させる方法を示します。 イベントはデリゲート型を持ち、"^" シンボルを使用して宣言されることに注意してください。

[!code-cpp[cx_events#01](../cppcx/codesnippet/CPP/cx_events/class1.h#01)]

### <a name="usage"></a>使用法

次の例では、サブスクライブ側のクラスが `+=` 演算子を使用してイベントにサブスクライブし、イベントが発生したときに呼び出されるイベント ハンドラーを指定する方法を示します。 指定された関数が、 `EventTest` 名前空間でパブリッシャー側で定義されたデリゲートの署名と一致していることに注目してください。

[!code-cpp[cx_events#02](../cppcx/codesnippet/CPP/eventsupportinvs/eventclientclass.h#02)]

> [!WARNING]
> 細心の注意を払って循環参照を回避する場合を除き、一般にイベント ハンドラーにはラムダではなく名前付き関数を使用する方が適しています。 名前付き関数では弱い参照によって "this" ポインターをキャプチャするのに対し、ラムダでは強い参照によってこのポインターをキャプチャし、循環参照を作成します。 詳細については、「 [Weak references and breaking cycles (C++/CX) (弱参照と循環の解除 (C++/CX))](../cppcx/weak-references-and-breaking-cycles-c-cx.md)」を参照してください。

### <a name="custom-add-and-remove-methods"></a>カスタムの add メソッドと remove メソッド

内部的には、イベントには add メソッド、remove メソッド、および raise メソッドがあります。 クライアント コードがイベントにサブスクライブすると、add メソッドが呼び出され、渡されたデリゲートが、イベントの呼び出しリストに追加されます。 パブリッシャー クラスがイベントを呼び出します。すると、raise() メソッドが呼び出され、リスト内の各デリゲートが順番に呼び出されます。 サブスクライバーは、デリゲートの一覧から自身を削除できます。これにより、イベントの remove メソッドが呼び出されます。 ユーザーがコードでこれらのメソッドを定義していない場合に備えて、コンパイラには、既定バージョンのメソッドが用意されています。これらは単純なイベントと呼ばれます。 多くの場合、単純なイベント以外に必要とされることはありません。

サブスクライバーの追加または削除に応じてカスタム ロジックを実行する必要がある場合に、イベントのカスタム add、remove、および raise メソッドを指定できます。 たとえば、イベントのレポートにのみ必要な負荷の高いオブジェクトがある場合、クライアントがイベントを実際にサブスクライブするまでオブジェクトの作成を延期できます。

次の例は、カスタムの add、remove、および raise メソッドをイベントに追加する方法を示しています。

[!code-cpp[cx_events#03](../cppcx/codesnippet/CPP/cx_events/class1.h#03)]

## <a name="removing-an-event-handler-from-the-subscriber-side"></a>サブスクライバー側からのイベント ハンドラーの削除

まれに、前にサブスクライブしたイベントのイベント ハンドラーを削除する必要が生じることがあります。 たとえば、他のイベント ハンドラーに置き換える場合や、ハンドラーが保持するリソースを削除する場合です。 ハンドラーを削除するには、 `+=` 演算から返される EventRegistrationToken を保存しておく必要があります。 その後、トークンの `-=` 演算子を使用してイベント ハンドラーを削除します。  ただし、元のハンドラーは削除した後でも呼び出すことができます。 したがって、イベント ハンドラーを削除する場合は、メンバー フラグを作成し、イベントが削除された場合にフラグをセットします。その後、イベント ハンドラーでフラグをチェックし、セットされている場合は直ちに戻ります。 次の例に、基本的なパターンを示します。

[!code-cpp[cx_events#04](../cppcx/codesnippet/CPP/eventsupportinvs/eventclientclass.h#04)]

### <a name="remarks"></a>Remarks

複数のハンドラーが、同じイベントに関連付けられている場合があります。 イベント ソースは、同じスレッドからすべてのイベント ハンドラーを順番に呼び出します。 イベント ハンドラー メソッド内でイベント レシーバーがブロックする場合、このイベントに対する他のイベント ハンドラーの呼び出しからイベント ソースをブロックします。

イベント ソースがイベント レシーバーのイベント ハンドラーを呼び出す順序は保証されず、呼び出しごとに異なる可能性があります。

## <a name="see-also"></a>関連項目

[型システム](../cppcx/type-system-c-cx.md)<br/>
[デリゲート](../cppcx/delegates-c-cx.md)<br/>
[Visual C 言語リファレンス](../cppcx/visual-c-language-reference-c-cx.md)<br/>
[名前空間参照](../cppcx/namespaces-reference-c-cx.md)
